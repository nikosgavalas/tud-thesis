#!/usr/bin/env python

import sys
import csv
import signal
from argparse import ArgumentParser

from src.lsmtree import LSMTree


def write_exit_msg():
    if sys.stdout.isatty():
        sys.stdout.write('Use q or Ctrl-D to exit.\n')
        sys.stdout.flush()


def signal_handler(sig, frame):
    write_exit_msg()


def parse(fd, args):
    db = LSMTree(args.d, args.r, args.s, args.m)
    csv_reader = csv.reader(fd, delimiter=' ', quotechar='"')
    for row in csv_reader:
        if not row:
            continue
        op = row[0]
        if op == 's' or op == 'w':
            key = row[1]
            value = row[2]
            db.set(key.encode(), value.encode())
        elif op == 'g' or op == 'r':
            key = row[1]
            sys.stdout.write(db.get(key.encode()).decode())
            sys.stdout.write('\n')
            sys.stdout.flush()
        elif op == 'q':
            return


def main():
    signal.signal(signal.SIGINT, signal_handler)

    parser = ArgumentParser()
    parser.add_argument('-f', type=str, help='path to input file')
    parser.add_argument('-d', type=str, help='path to data directory', default='./data')
    parser.add_argument('-r', type=int, help='max runs per level', default=3)
    parser.add_argument('-p', type=int, help='density factor', default=20)
    parser.add_argument('-m', type=int, help='memtable bytes limit', default=1000000)
    args = parser.parse_args()

    write_exit_msg()

    if args.f:
        with open(args.f, 'r') as fd:
            parse(fd, args)
    else:
        parse(sys.stdin, args)


if __name__ == '__main__':
    main()
